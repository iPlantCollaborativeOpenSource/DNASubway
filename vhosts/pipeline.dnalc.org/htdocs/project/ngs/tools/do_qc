do_qc: change R into blinking R and remove link from QC button

%#-----------------------------------------------------------------
<%args>
	$pid => 0
</%args>
<%once>
	use Data::Dumper;
	use DNALC::Pipeline::App::NGS::ProjectManager ();
	#use DNALC::Pipeline::User ();
	
	#my %clades = ();
</%once>
<%init>
	$m->session->{pipeline} ||= {};
	my $s = $m->session->{pipeline};
	
	my $apif = iPlant::FoundationalAPI->new(
			user => $s->{username},
			token => $s->{api_token},
			debug => 0,
		);

	my $pm = DNALC::Pipeline::App::NGS::ProjectManager->new({project => $pid, debug => 0});
	$pm->api_instance($apif) if $apif;

	my $proj = $pm->project;

	# project's owner
	my $is_owner = $s->{user_id} == $proj->user_id if $proj;
	my $qc_status = $is_owner ? $pm->qc_status->{status} : 'disabled';

	# check if we have a qc-lock on this project
	# check qc_status, it must be "not-processed" to continue

	my $lock_key = 'qc-lock-' . ($proj || 0);
	my $lock = $m->cache->get($lock_key);
	if ($proj && !defined $lock && $qc_status eq "not-processed") {
		# if not, apply the lock
		$m->cache->set($lock_key, 1, '40 sec');
		print STDERR "do_QC: LOCKED\n";

		#launch qc_job
		#my $qc_jobs = eval { $pm->do_qc; };
		my $qc_jobs = $pm->do_qc;

		# remove the lock
		$m->cache->remove($lock_key);
		print STDERR "do_QC: UNLOCKED\n";
	} else {
		print STDERR "do_QC: no QCing\n";
		#print STDERR "do_QC: proj: $proj\n";
		print STDERR "do_QC: locked: $lock\n";
		print STDERR "do_QC: status: $qc_status\n";
	}
</%init>
<%flags>
	inherit => undef
</%flags>