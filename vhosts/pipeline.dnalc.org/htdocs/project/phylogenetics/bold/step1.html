<div id="BOLDstep">Step 1 of 6</div>
<div id="BOLDmain">
	<h2>Select sequences</h2>
<span style="color:red">
<& /_messages &>
</span>
	<p>
<form id="bform" method="POST">
<input type="hidden" name="bstep" value="1" />
		Select a sequence to submit:
		<div>
%# Don't be allowed to chose a sequence if it doesn't have a consensus AND if you're already submitted that sequence??
%# And on selecting a sequence to submit, we then check to ensure it has been paired correctly. 

		
%if (@pairs) {
%	for (@pairs) {
%		my $name = lcs_name( map {$_->seq->display_id}  $_->paired_sequences);
%#		next if $_->consensus eq "";
%		if ($_->consensus eq ""){
			<div style="color:#888;font-style:italic"><input type="radio" disabled><% $name |html%> - No consensus built for this pair, please go back and run the Consensus Builder</div>
%		} elsif (exists $pair_quality{$_} ) {
			<div style="color:#888;font-style:italic"><input type="radio" disabled><% $name |html%> - You cannot submit this pair because one or both sequences in this pair are of poor quality</div>
%		} else {
			<div><input type="radio" name="sel_seq" id="p<% $_ |html %>" value="p<% $_->id %>" \
			<% defined $sel_seq{"p".$_->id} ? "checked=\"checked\"" : "" %> \
			<% defined $seq_submitted{$_->id} ? "disabled=\"disabled\"" : ""%> /><% $name |html%>
%			if (defined $seq_submitted{$_->id}) {
				(<small>already submitted</small>)\
%			}
		</div>
%		}
%	}
%} else {
<p style="color:red">You have no pairs or you have not built your consensus sequence. You must pair your sequences and build your consensus sequence in order for them to appear here.</p>
%}

		</div>
</form>
	</p>
</div>
<div id="BOLDfooter">
	<a href="#" onclick="top.phy.close_window('BOLD');">Cancel</a>&nbsp;
	<a href="#" onclick="phy.next_bold_step();">Continue</a>
</div>

<%args>
	#$pid => 0
	$bstep => undef
	@sel_seq => ()
</%args>
<%once>
	use DNALC::Pipeline::App::Phylogenetics::ProjectManager ();
	use DNALC::Pipeline::Phylogenetics::BoldSeq ();
	#use DNALC::Pipeline::Config ();
	use DNALC::Pipeline::Phylogenetics::Pair ();
	use DNALC::Pipeline::Phylogenetics::PairSequence();
	use DNALC::Pipeline::Phylogenetics::DataSequence ();
	use DNALC::Pipeline::Phylogenetics::DataFile ();
	use DNALC::Pipeline::Utils qw/lcs_name/;
	use Data::Dumper;
	
</%once>
<%init>
	my $s = $m->session->{pipeline};
	my $pid = $s->{boldpid};
	$s->{"bold_$pid"} ||= {};
	my $bs = $s->{"bold_$pid"};
	
	#my $pair = DNALC::Pipeline::Phylogenetics::Pair->new();
	
	#print STDERR "S1. PID = ", $pid, Dumper($s), $/;

	my $pm = DNALC::Pipeline::App::Phylogenetics::ProjectManager->new($pid);
	my $proj = $pm->project;
	unless ($proj && $proj->user_id == $s->{user_id}) {
		$m->comp('/_message_add', 'Project not found!', 'error');
		$m->redirect("./?pid=$pid");
		#print "Project not found!";
		return;
	}
	#my @pairs = ();#$pm->pairs;
	my @pairs = $pm->pairs;
	
	my %pair_quality;
	for my $pair (@pairs){
		my @quals;
		my @seqs = DNALC::Pipeline::Phylogenetics::PairSequence->search(pair_id => $pair);
		for my $seq (@seqs){
			my $file_id = $seq->seq_id->file_id;
			my $seq_has_low_q = DNALC::Pipeline::Phylogenetics::DataFile->retrieve($file_id)->has_low_q;
			
			if ($seq_has_low_q) {
				$pair_quality{$pair} = 1;
				last;
			}
		}
	}
	
	#print STDERR Dumper(\%pair_quality), $/;
	
	my %seq_submitted = map {$_->pair_id => 1} 
		DNALC::Pipeline::Phylogenetics::BoldSeq->search(project_id => $proj->id);
	
	# get non paired sequences
	#my @sequences = $pm->initial_sequences;
	
	my %sel_seq = ();
	
	my $has_errors = 0;
	if ($r->method eq "POST") {

		if (@sel_seq) {
			my $pair_id = $sel_seq[0];
			$pair_id =~ s/p//;
			
			## check to make sure the pair exists and belongs to this user
			if (!grep {$pair_id == $_->id} @pairs){
				$m->comp('/_message_add', 'You have tried to submit a pair which does not exist or does not belong to you. Please try again by selecting one of the sequences available to you below.', 'error');
				$m->redirect("./step1.html");
			}
			
			## check to make sure the sequence is paired correctly here
			my @pair_seqs = DNALC::Pipeline::Phylogenetics::PairSequence->search(pair_id => $pair_id);
			#print STDERR "1) ", $pair_seqs[0]->strand, "; 2) ", $pair_seqs[1]->strand, $/;
			if (!(($pair_seqs[0]->strand eq "F" && $pair_seqs[1]->strand eq "R") 
				|| ($pair_seqs[0]->strand eq "R" && $pair_seqs[1]->strand eq "F"))
			) {
				$m->comp('/_message_add', 'Please double check this pair, it does not appear to be paired correctly. You must ensure your pair is comprised of <strong>one forward</strong> read <br />and <strong>one reverse</strong> read. After rebuilding your pair, be sure to rebuild the consensus sequence as well.', 'error');
				#$m->redirect("./step1.html");
				$has_errors = 1;
			}
			
			## here we check again to ensure they are not trying to submit a sequence of poor quality
			if (exists $pair_quality{$pair_id} ) {
				$m->comp('/_message_add', 'You cannot submit this pair because one or both sequences in this pair are of poor quality.', 'error');
				#$m->redirect("./step1.html");
				$has_errors = 1;
			}
			
			## here we check again to ensure the pair they are attempting to submit has a consensus
			if (DNALC::Pipeline::Phylogenetics::Pair->retrieve($pair_id)->consensus eq "" ) {
				$m->comp('/_message_add', 'You cannot submit this pair because there is no consensus sequence built. In order to be able to submit this pair, please go back and run the Consensus Builder.', 'error');
				#$m->redirect("./step1.html");
				$has_errors = 1;
			}
			
			# TODO: ckecked selected sequences (? - this was a note from cornel)
			$bs->{sel_seq} = \@sel_seq;
			$bs->{step1} = 1;
			
			if ($has_errors){
				$m->redirect("./step1.html");
			}
			
			$m->redirect("./step2.html");
		}
		else {
			$m->comp('/_message_add', 'No sequences were selected!', 'error');
			$m->redirect("./step1.html");
		}
	}
	else {
		%sel_seq = map {$_ => 1} @{$bs->{sel_seq}};
	}

</%init>